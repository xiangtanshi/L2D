'''
generate the template of shape, texture, background, store them in /data/counterfactual
shape templates: generated by cgn.u2net with images in train,valid,test dataset
texture templates: randomly select a few(8 to 10 for each class) images from the training set and crop texture from them
background templates: generated by cgn 
'''
import argparse
import os
import torch
import torchvision
from torch.utils.data import DataLoader
from tqdm import tqdm
from cgn import CGN
from u2net import U2NET
from cgn_class import *
import argparse
import re

# save as grid image
def save_grid(im, path):
    torchvision.utils.save_image(im.detach().cpu(), path, normalize=True)


def toggle_grad(model, on_or_off):
    for param in model.parameters():
        param.requires_grad = on_or_off

def mkdir(path):
    folder = os.path.exists(path)
    if not folder:
        os.makedirs(path)

parser = argparse.ArgumentParser(description='parameter setting for generating templates, mainly for loading the data.')
parser.add_argument('--mechanism', type=str, default='texture')
parser.add_argument('--device',default=0,type=int)
parser.add_argument('--data',type=int,default=0,help='0 denotes con2, 1 denotes val1')
args =  parser.parse_args()

def main(args):
    
    if args.mechanism == 'shape': 
        # extract shape for sets in animals and vehicles
        u2net_weights = './models/cgn/u2net.pth'
        u2net = U2NET.initialize(u2net_weights).eval()
        toggle_grad(u2net, False)

        device = torch.device('cuda:{}'.format(args.device))
        u2net = u2net.to(device)

        if args.data == 0:
            loader = DataLoader(dataset=con2__data, batch_size=1, shuffle=False, num_workers=1)  

            # create a txt file to record the above shape image laocation
            con2_mask =  open('./datas/counter/mask/con2-mask.txt','w')
            con2 = open('./datas/NICO_paths/context2.txt','r') 
            lines = con2.readlines()
            # 遍历每一行并进行修改
            for i, line in enumerate(lines):
                # 使用正则表达式提取需要的部分
                match = re.search(r'(./datas/NICO_DG/\w+/[^/]+/)(\w+_\d+)(\.jpg\$\d+)', line)
                
                if match:
                    # 替换路径
                    new_path = "./datas/counter/mask/con2/"
                    # 使用行号（从0开始）作为新的标识符
                    new_identifier = str(i)
                    # 保持文件扩展名和标签不变
                    extension_and_label = match.group(3)
                    # 构建新的行
                    new_line = f"{new_path}{new_identifier}{extension_and_label}\n"
                    # 将新行写入2.txt
                    con2_mask.write(new_line)

            con2.close()
            con2_mask.close()
        else:
            loader = DataLoader(dataset=val1__data, batch_size=1, shuffle=False, num_workers=1)

            val1_mask = open('./datas/counter/mask/val1-mask.txt','w')
            val1 = open('./datas/NICO_paths/val1.txt','r')
            lines = val1.readlines()
            # 遍历每一行并进行修改
            for i, line in enumerate(lines):
                # 使用正则表达式提取需要的部分
                match = re.search(r'(./datas/NICO_DG/\w+/[^/]+/)(\w+_\d+)(\.jpg\$\d+)', line)
                
                if match:
                    # 替换路径
                    new_path = "./datas/counter/mask/val1/"
                    new_identifier = str(i)
                    extension_and_label = match.group(3)
                    new_line = f"{new_path}{new_identifier}{extension_and_label}\n"
                    val1_mask.write(new_line)
        
            val1.close()
            val1_mask.close()

        bar = tqdm(total=len(loader))   
        count = -1
        with torch.no_grad():
            for image,label in loader:   
                bar.update()
                count += 1
                image = image.to(device)
                m = u2net(image)
                m = torch.clamp(m, 0.0001, 0.9999).repeat(1, 3, 1, 1)
                if args.data == 0:
                    save_grid(m, './datas/counter/mask/con2/{}.jpg'.format(count))  
                else:
                     save_grid(m, './datas/counter/mask/val1/{}.jpg'.format(count))
                
        bar.close()
         
    elif args.mechanism == 'texture':
        # foreground texture rearrange and create pyramid feature

        loader = DataLoader(dataset=texture,batch_size=1,shuffle=False)   #

        with open('./datas/counter/foreground/texture.txt','r') as file:
            lines = [line.strip() for line in file.readlines()]

        feature_path_file = ''
        
        def mkdir(path):
            folder = os.path.exists(path)
            if not folder:
                os.makedirs(path)

        idx = -1
        for img1,label in loader:       
            idx += 1
            m = torch.zeros(1,3,256,256)
            path = lines[idx]
            modified_path = path.replace("texture", "pyramid").rsplit("/", 1)[0]    #
            mkdir(modified_path)
            for row in range(4):
                for col in range(4):
                    m[:,:,64*row:64*(row+1),64*col:64*(col+1)] = img1    #
            ft_path = modified_path + '/{}.jpg'.format(re.search(r'\d+', path).group())
            save_grid(m, ft_path)    
            feature_path_file += (ft_path + '${}\n'.format(label.item())) 
        with open('./datas/counter/foreground/feature.txt', 'w') as f:  # 
            f.write(feature_path_file)

    elif args.mechanism == 'background':
        # background template   
    
        list_background = range(100)
        list_target = list_background

        cgn = CGN(batch_sz=1, pretrained=False)
        device = torch.device('cuda:{}'.format(args.device))
        weights = torch.load('./weights/cgn.pth', map_location='cpu')
        cgn.load_state_dict(weights)
        cgn = cgn.to(device)
        bar = tqdm(total=len(list_target))

        for idx,clas in enumerate(list_target):

            ys = (clas,clas,clas)
            inp0,inp1,inp2 = cgn.get_inp(ys)
            bgs = cgn.f_bg(*inp2)
            bar.update()

            for i in range(len(bgs)):
                save_grid(bgs[i], './datas/counter/background/{}.jpg'.format(idx))
        bar.close()
    
    else:
        print('nothing required, exit!')
     

if __name__ == '__main__':

    main(args)
